using System;
using System.Runtime.CompilerServices;

namespace Utility;
internal static partial class VEC_Generate {
    //##########################################################################################################################################################
    //##########################################################################################################################################################
    //
    //  The starting orientations for these are designed around being practical, not "correct".
    //
    //  Theta in Radians.
    //  Positive rotations are Clockwise.
    //
    //##########################################################################################################################################################
    //##########################################################################################################################################################
    //
    //  Vector2  FROM  Angle (in radians).
    //
    //      (  0) == ( 0, 1)
    //      ( 90) == ( 1, 0)
    //      (180) == ( 0,-1)
    //      (270) == (-1, 0)
    //      (360) == ( 0, 1)
    //
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static vec2 FromAng(float Theta) => new vec2(
        sin(Theta),
        cos(Theta)
    );

    //##########################################################################################################################################################
    //##########################################################################################################################################################
    //##########################################################################################################################################################
    //##########################################################################################################################################################
    //##########################################################################################################################################################
    //##########################################################################################################################################################
    //##########################################################################################################################################################
    //##########################################################################################################################################################
    //
    //  Vector3  FROM  Pitch.
    //  Result on plane spanning YZ.
    //
    //      (  0) == ( 0, 0,-1)
    //      ( 90) == ( 0,-1, 0)
    //      (180) == ( 0, 0, 1)
    //      (270) == ( 0, 1, 0)
    //      (360) == ( 0, 0,-1)
    //
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static vec3 FromPch(float Theta) => new vec3(
        0f,
        -sin(Theta),
        -cos(Theta)
    );

    //==========================================================================================================================================================
    //
    //  Vector3  FROM  Yaw.
    //  Result on plane spanning XZ.
    //
    //      (  0) == ( 0, 0,-1)
    //      ( 90) == ( 1, 0, 0)
    //      (180) == ( 0, 0, 1)
    //      (270) == (-1, 0, 0)
    //      (360) == ( 0, 0,-1)
    //
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static vec3 FromYaw(float Theta) => new vec3(
        sin(Theta),
        0f,
        -cos(Theta)
    );

    //==========================================================================================================================================================
    //
    //  Vector3  FROM  Roll.
    //  Result on plane spanning XY.
    //
    //      (  0) == ( 0, 1, 0)
    //      ( 90) == ( 1, 0, 0)
    //      (180) == ( 0,-1, 0)
    //      (270) == (-1, 0, 0)
    //      (360) == ( 0, 1, 0)
    //
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static vec3 FromRol(float Theta) => new vec3(
        sin(Theta),
        cos(Theta),
        0f
    );

    //##########################################################################################################################################################
    //##########################################################################################################################################################
    //
    //  Vector3  FROM  Pitch & Yaw.
    //
    //      (  0,   0) == ( 0, 0,-1)
    //      (  0,  90) == ( 1, 0, 0)
    //      (  0, 180) == ( 0, 0, 1)
    //      (  0, 270) == (-1, 0, 0)
    //
    //      (-90,   0) == ( 0, 1, 0)
    //      (  0,   0) == ( 0, 0,-1)
    //      ( 90,   0) == ( 0,-1, 0)
    //
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static vec3 FromPchYaw(float Pch, float Yaw) {
        float CosPch = cos(Pch);

        return new vec3(
             CosPch * sin(Yaw),
                     -sin(Pch),
            -CosPch * cos(Yaw)
        );
    }

    //##########################################################################################################################################################
    //##########################################################################################################################################################
    //
    //  Rotation(Pitch, Yaw, 0)    FROM    Unit-Pointing(X, Y, Z)
    //
    //      ( 0, 0,-1) == (  0,  0, 0)
    //      ( 0,-1, 0) == ( 90,  0, 0)
    //      ( 0, 0, 1) == (  0,180, 0)
    //      ( 0, 1, 0) == (-90,  0, 0)
    //
    //      ( 0, 0,-1) == (  0,  0, 0)
    //      ( 1, 0, 0) == (  0, 90, 0)
    //      ( 0, 0, 1) == (  0,180, 0)
    //      (-1, 0, 0) == (  0,270, 0)
    //
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static vec3 RotFromVec(vec3 V) {
        float Pch, Yaw;

        V.z = -V.z;
        Pch = atan2(-V.y, sqrt(V.x*V.x + V.z*V.z));

        if (abs(Pch) >= (PIH-EPSILON)) {
            Pch = sign(PIH, Pch);
            Yaw = 0f;
        } else {
            Yaw = wrap(atan2(V.x, V.z), 0f, PI2);
        }

        return new vec3(Pch, Yaw, 0f);
    }

    //##########################################################################################################################################################
    //##########################################################################################################################################################
}
