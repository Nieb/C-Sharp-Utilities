using System;
using System.Runtime.CompilerServices;

namespace Utility;
internal static partial class VEC_Generate {
    //##########################################################################################################################################################
    //##########################################################################################################################################################
    //
    //  The starting orientations for these are designed around being practical, not "correct".
    //
    //  Theta in Radians.
    //  Positive rotations are Clockwise.
    //
    //##########################################################################################################################################################
    //##########################################################################################################################################################
    ///
    /// Vector2  FROM  Angle.
    ///
    ///     (  0) == ( 0, 1)
    ///     ( 90) == ( 1, 0)
    ///     (180) == ( 0,-1)
    ///     (270) == (-1, 0)
    ///     (360) == ( 0, 1)
    ///
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static vec2 FromAng(float Theta) => (
        sin(Theta),
        cos(Theta)
    );

    //##########################################################################################################################################################
    //##########################################################################################################################################################
    ///
    /// Vector3  FROM  Pitch.
    /// Result on plane spanning YZ.
    ///
    ///     (  0) == ( 0, 0,-1)
    ///     ( 90) == ( 0,-1, 0)
    ///     (180) == ( 0, 0, 1)
    ///     (270) == ( 0, 1, 0)
    ///     (360) == ( 0, 0,-1)
    ///
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static vec3 FromPch(float Theta) => (
        0f,
        -sin(Theta),
        -cos(Theta)
    );

    //==========================================================================================================================================================
    ///
    /// Vector3  FROM  Yaw.
    /// Result on plane spanning XZ.
    ///
    ///     (  0) == ( 0, 0,-1)
    ///     ( 90) == ( 1, 0, 0)
    ///     (180) == ( 0, 0, 1)
    ///     (270) == (-1, 0, 0)
    ///     (360) == ( 0, 0,-1)
    ///
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static vec3 FromYaw(float Theta) => (
        sin(Theta),
        0f,
        -cos(Theta)
    );

    //==========================================================================================================================================================
    ///
    /// Vector3  FROM  Roll.
    /// Result on plane spanning XY.
    ///
    ///     (  0) == ( 0, 1, 0)
    ///     ( 90) == ( 1, 0, 0)
    ///     (180) == ( 0,-1, 0)
    ///     (270) == (-1, 0, 0)
    ///     (360) == ( 0, 1, 0)
    ///
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static vec3 FromRol(float Theta) => (
        sin(Theta),
        cos(Theta),
        0f
    );

    //##########################################################################################################################################################
    //##########################################################################################################################################################
    ///
    /// Vector3  FROM  Pitch & Yaw.
    ///
    ///     (  0,   0) == ( 0, 0,-1)
    ///     (  0,  90) == ( 1, 0, 0)
    ///     (  0, 180) == ( 0, 0, 1)
    ///     (  0, 270) == (-1, 0, 0)
    ///
    ///     (-90,   0) == ( 0, 1, 0)
    ///     (  0,   0) == ( 0, 0,-1)
    ///     ( 90,   0) == ( 0,-1, 0)
    ///
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static vec3 FromPchYaw(float Pch, float Yaw) {
        float CosPch = cos(Pch);

        return (
             CosPch * sin(Yaw),
                     -sin(Pch),
            -CosPch * cos(Yaw)
        );
    }

    //##########################################################################################################################################################
    //##########################################################################################################################################################
    ///
    /// Rotation Vector3(Pitch, Yaw, 0)
    ///   FROM
    /// Pointing Vector3(X, Y, Z)
    ///
    ///     ( 0, 0,-1) == (  0,  0, 0)
    ///     ( 0,-1, 0) == ( 90,  0, 0)
    ///     ( 0, 0, 1) == (  0,180, 0)
    ///     ( 0, 1, 0) == (-90,  0, 0)
    ///
    ///     ( 0, 0,-1) == (  0,  0, 0)
    ///     ( 1, 0, 0) == (  0, 90, 0)
    ///     ( 0, 0, 1) == (  0,180, 0)
    ///     (-1, 0, 0) == (  0,270, 0)
    ///
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static vec3 RotFromVec(vec3 Vn) {
        Vn.z = -Vn.z;

        float Pch = atan2(-Vn.y, sqrt(Vn.x*Vn.x + Vn.z*Vn.z));

        float Yaw = (abs(Pch) >= (PIH-EPSILON)) ? 0f
                                                : wrap(atan2(Vn.x, Vn.z), 0f, PI2); //-PI, PI);

        return (Pch, Yaw, 0f);
    }

    //##########################################################################################################################################################
    //##########################################################################################################################################################
}
